# 맵, 필터, 리듀스

스위프트는 함수를 일급 객체로 취급한다. 따라서 함수를 다른 함수의 전달인자로 사용할 수 있다. 매개변수로 함수를 갖는 함수를 고차함수라고 한다. 대표적으로 맵, 필터 리듀스 등이 있다.

<br><br>

## 1. 맵(Map)

* 맵은 자신을 호출할 때 매개변수로 전달된 함수를 실행하여 그 결과를 다시 반환해주는 함수이다.
  * 컨테이너가 담고 있던 각각의 값을 매개변수를 통해 받은 함수에 적용한 후 다시 컨테이너에 포장하여 반환한다.
* Sequence, Collection 프로토콜을 따르는 타입과 옵셔널은 모두 사용 가능하다
  * 배열, 딕셔너리, 세트, 옵셔널 등

<br>

`container.map(f(x))` 컨테이너의 map 메서드 호출

-> `return f(container의 각 요소)` (새로운 컨테이너 반환)


<br>

* for-in 구문과 비슷하지만 코드의 재사용 측면이나 컴파일러 최척화측면에서 성능 차이가 있다.
* 다중 스레드 환경일 떄 대상 컨테이너의 값이 스레드에서 변경되는 시점에 다른 스레드에서도 동시에 값이 변경되려고 할때 발생하는 부작용 방지 가능


```swift
let numbers: [Int] = [0, 1, 2, 3, 4]

var doubledNumbers: [Int] = [Int]()
var strings: [String] = [String]()

// for 구문 사용
for number in numbers {
    doubledNumbers.append(number * 2)
    strings.append("\(number)")
}

print(doubledNumbers)    // [0, 2, 4, 6, 8]
print(strings)           // ["0", "1", "2", "3", "4"]



// map 메서드 사용
doubledNumbers = numbers.map( { (number: Int) -> Int in
    return number * 2
})
strings = numbers.map( { (number: Int) -> String in
    return "\(number)"
})

print(doubledNumbers)   // [0, 2, 4, 6, 8]
print(strings)          // ["0", "1", "2", "3", "4"]
```

* map 사용하면 처음에 빈 배열을 생성해 주는 작업도 필요 없다.
* 배열의 append 연산을 실행하는 시간도 필요 없다.
  
<br>

* 클로저 표현식으 사용하여 간략화

```swift
let numbers: [Int] = [0, 1, 2, 3, 4]

// 기본 클로저 표현식 사용
var doubledNumbers = numbers.map( { (number: Int) -> Int in
    return number * 2
})

// 매개변수 및 반환 타입 생략
doubledNumbers = numbers.map( { return $0 * 2 })

// 반환 키워드 생략
doubledNumbers = numbers.map( { $0 * 2 })

// 후행 클로저 사용
doubledNumbers = numbers.map { $0 * 2 }
```

<br>

* 클로저 재사용 가능하도록 구현

```swift
let evenNubmers: [Int] = [0, 2, 4, 6, 8]
let oddNumbers: [Int] = [0, 1, 3, 5, 7]
let multiplyTwo: (Int) -> Int = { $0 * 2 }

let doubledEvenNumbers = evenNubmers.map(multiplyTwo)
print(doubledEvenNumbers)   // [0, 4, 8, 12, 16]

let doubledOddNumbers = oddNumbers.map(multiplyTwo)
print(doubledOddNumbers)    // [0, 2, 6, 10, 14]
```

<br>

* 다양한 종류의 컨테이너에서 사용 가능

```swift
let alphabetDictionary: [String: String] = ["a":"A", "b":"B"]

var keys: [String] = alphabetDictionary.map { (tuple: (String, String)) ->
    String in
    return tuple.0
}
print(keys)     // ["b", "a"]

keys = alphabetDictionary.map{ $0.0 }

let values: [String] = alphabetDictionary.map{ $0.1 }
print(keys)     // ["b", "a"]
print(values)   // ["B", "A"]


var numberSet: Set<Int> = [1, 2, 3, 4, 5]
let resultSet = numberSet.map{ $0 * 2 }
print(resultSet)    // [4, 2, 6, 8, 10]


let optionalInt: Int? = 3
let resultInt: Int? = optionalInt.map{ $0 * 2}
print(resultInt)    // Optional(6)

let range: CountableClosedRange = (0...3)
let resultRange: [Int] = range.map{ $0 * 2}
print(resultRange)  // [0, 2, 4, 6]
```

<br><br>

## 2. 필터(FIlter)
* 컨테이너 내부의 값을 걸러서 추출하는 역할을 하는 고차함수이다. 
* filter 함수의 매개변수로 전달되는 함수의 반환 타입은 Bool이다.

```swift
let numbers: [Int] = [0, 1, 2, 3, 4, 5]

let evenNumbers: [Int] = numbers.filter { (number: Int) -> Bool in
    return number % 2 == 0
}
print(evenNumbers)  // [0, 2, 4]

let oddNumbers: [Int] = numbers.filter { $0 % 2 == 1 }
print(oddNumbers)   // [1, 3, 5]
```

<br>

* 콘텐츠의 변형 후에 필터링
```swift
var numbers: [Int] = [0, 1, 2, 3, 4, 5]

numbers = numbers.map { $0 + 3 }

let evenNumbers: [Int] = numbers.filter { (number: Int) -> Bool in
    return number % 2 == 0
}
print(evenNumbers)  // [4, 6, 8]

let oddNumbers: [Int] = numbers.filter { $0 % 2 == 1 }
print(oddNumbers)   // [3, 5, 7]
```

<br>

## 3. 리듀스(Reduce)

* 컨테이너 내부의 콘텐츠를 하나로 합하는 기능을 실행하는 고차함수이다.
  * 배열이라면 배열의 모든 값을 전달인자로 전달받은 클로저의 연산 결과로 합해준다.
# 모나드(Monad)

* 함수형 프로그래밍에서의 모나드는 순서가 있는 연산을 처리할 때 자주 활용하는 디자인 패턴이다.
* 사용하는 곳에 따라 수학의 범주론에서 말하는 모나드인지 특정 디자인 패턴을 따르는 모나드인지가 다르다
* 프로그래밍에서 모나드가 갖춰야 하는 조건
  * 타입을 인자로 받는 타입(특정 타입의 값을 포장)
  * 특정 타입의 값을 포장한 것을 반환하는 함수(메서드)가 존재
  * 포장된 값을 변환하여 같은 형태로 포장하는 함수(메서드)가 존재

<br><br>

## 1. 컨텍스트(Context)

* 콘텐츠(Contents)를 담은 그 무엇인가를 뜻한다.

<br><br>

## 2. 함수객체(Functor)

맵은 컨테이너의 값을 변형시킬 수 있는 고차함수이다. 그리고 옵셔널은 컨테이너와 값을 갖기 때문에 맵 함수를 사용할 수 있다.

```swift
func addThree(_ num: Int) -> Int {
    return num + 3
}

let n = Optional(2).map(addThree)
print(n)    // Optional(5)
```

<br>

```swift
var value: Int? = 2
value.map { $0 + 3 }    // Optional(5)

value = nil
value.map { $0 + 3 }    // nil(= Optional<Int>.none)
```

* 함수객체(Functor)란 맵을 적용할 수 있는 컨테이너 타입
  * Array, Dictionary, Set 등 스위프트의 컬렉션 타입이 함수의 객체이다.

* 함수객체와 맵 매서드의 동작 순서
  1. 맵이 함수를 인자로 받음 ( addThree(_:) )
  2. 함수객체에 맵이 전달 받은 함수를 적용 ( Optional(2) )
  3. 새로운 함수객체를 반환 ( Optional(5) )

<br>

* 옵셔널의 map 메서드 구현

```swift
extension Optional {
    func map<U>(f: (Wrapped) -> U) -> U? {
        switch self {
        case .some(let x): return f(x)
        case .none: return .none
        }
    }
}
```

<br><br>

## 3. 모나드(Monad)

* 함수객체 중에서 자신의 컨텍스트와 같은 컨텍스트의 형태로 맵핑할 수 있는 함수객체를 닫힌 함수객체(Endofunctor)라고 한다.
  * 모나드는 닫힌 함수객체이다.
* 함수객체는 포장된 값에 함수를 적용할 수 있다.
  * 모나드도 컨텍스트에 포장된 값을 처리하여 포장된 값을 컨텍스트에 다시 반환하는 함수(맵)를 적용할 수 있다.
* 플랫맵(flatMap): 맵과 같이 함수를 매개변수로 받고, 옵셔널은 모나드이므로 플랫맵을 사용할 수 있다.
  * 맵핑의 결과가 함수객체와 같은 컨텍스를 반환하는 함수객체를 모나드라고 한다.

<br>

```swift
func doubledEven(_ num: Int) -> Int? {
    if num.isMultiple(of: 2) {
        return num * 2
    }
    return nil
}

Optional(3).flatMap(doubledEven(_:))
```

  1. 컨텍스트로부터 값 추출
  2. 추출한 값을 doubleEven 함수에 전달 (짝수 아님)
  3. 빈 컨텍스트 반환

<br>

* 빈 컨텍스트에서 플랫맵 사용

```swift
Optional.none.flatMap(doubleEven)
```

1. 빈 컨텍스트
2. 플랫맵은 아무것도 하지 않음
3. 결국 다시 빈 컨텍스트 반환

<br>

* map VS flatMap
  * 플랫맵은 맵과 다르게 컨텍스트 내부의 컨텍스트를 모두 같은 위상으로 평평하게 펼쳐준다는 차이가 있다.
  * 포장된 값 내부의 포장된 값의 포장을 풀어서 같은 위상으로 펼쳐준다.

<br>

* Optional 타입에서 사용한 flatMap(_:) 메서드를 Sequence 타입이 Optional 타입의 Element를 포장한 경우에 compactMap(_:)라는 이름으로 사용한다. (사용방법은 같음)

```swift
let optionals: [Int?] = [1, 2, nil, 5]

let mapped: [Int?] = optionals.map { $0 }
let compactMapped: [Int] = optionals.compactMap { $0 }

print(mapped)           // [Optional(1), Optional(2), nil, Optional(5)]
print(compactMapped)    // [1, 2, 5]
```

* 삼중 컨테이너에 중첩된 맵과 플랫맵(콤팩트맵) 사용

```swift
let multipleContainer = [[1, 2, Optional.none], [3, Optional.none], [4, 5, Optional.none]]

let mappedMultipleContainer = multipleContainer.map{ $0.map{ $0 } }
let flatMappedMultipleContainer = multipleContainer.flatMap{ $0.compactMap{ $0 } }

print(mappedMultipleContainer)
// [[Optional(1), Optional(2), nil], [Optional(3), nil], [Optional(4), Optional(5), nil]]
print(flatMappedMultipleContainer)
// [1, 2, 3, 4, 5]
```

<br>

* flatMap의 활용

```swift
 func stringToInteger(_ string: String) -> Int? {
    return Int(string)
}

func integerToString(_ integer: Int) -> String? {
    return "\(integer)"
}

var optionalString: String?  = "2"

let flattenResult = optionalString.flatMap(stringToInteger)
    .flatMap(integerToString)
    .flatMap(stringToInteger)

print(flattenResult)    // Optional(2)

let mappedResult = optionalString.map(stringToInteger)  // 더 이상 체인 연결 불가
print(mappedResult)     // Optional(Optional(2))
```

<br>

* 옵셔널의 맵과 플랫맵의 정의

```swift
func map<U>(_ transform: (Wrapped) throws -> U) rethrows -> U?
func flatMap<U>(_ transform: (Wrapped) throws -> U?) rethrows -> U?
```

<br>

stringToInt는 Int? 타입을 반환한다. 따라서 U == Int? 이다. 맵에 stringToInt함수를
전달하면 최종 반환 타입이 Int?? 가된다. <br>
플랫맵에서는 U? == Int?가 된다. 즉 U == Int가 되기 떄문에 플랫맵의 동작 결과는 Int?타입을 반환하게 된다.

<br>

* 플랫맵을 사용하지 않고 옵셔널 바인딩을 통한 연산

```swift
func stringToInteger(_ string: String) -> Int? {
    return Int(string)
}

func integerToString(_ integer: Int) -> String? {
    return "\(integer)"
}
    
var optionalString: String?  = "2"

var result: Int?
if let string: String = optionalString {
    if let number: Int = stringToInteger(string) {
        if let finalString: String = integerToString(number) {
            if let finalNumber: Int = stringToInteger(finalString) {
                result = Optional(finalNumber)
            }
        }
    }
}
    
print(result)   // Optional(2)

if let string: String = optionalString,
   let number: Int = stringToInteger(string),
   let finalString: String = integerToString(number),
   let finalNumber: Int = stringToInteger(finalString) {
    result = Optional(finalNumber)
}

print(result)   // Optional(2)
```

<br>

* 플랫맵은 체이닝 중간에, 연산에 실패하는 경우나 값이 없어지는 경우(.none이 된다거나 nil이 된다는 등) 에는 별도의 예외 처리없이 빈 컨테이너를 반환한다.


```swift
func integerToNil(param: Int) -> String? {
    return nil
}

optionalString = "2"

result = optionalString.flatMap(stringToInteger)
    .flatMap(integerToNil)
    .flatMap(stringToInteger)

print(result)   // nil
```


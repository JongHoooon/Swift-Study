# 클로저(Closure)

> 클로저는 일정 기능을 하는 코드를 하나의 블록으로 모아놓은 것을 말한다. 클로저는 변수나 상수가 선언된 위치에서 참조(Reference)를 획득(Capture)하고 저장할 수 있다. 클로저의 몇 가지 모양 중 하나가 함수이다.

* 클로저의 세 가지 형태
  * 이름이 있으면서 어떤 값도 획득하지 않는 전역함수의 형태
  * 이름이 있으면서 다른 함수 내부의 값을 획득할 수 있는 중첩된 함수의 형태
  * 이름이 없고 주변 문맥에 따라 값을 획득할 수 있는 축약 문법으로 작성한 형태

<br><br>

* 클로저의 다양한 표현
  * 클로저는 매개변수와 반환 값의 타입을 문맥을 통해 유추할 수 있기 때문에 매개변수와 반환 값의 타입을 생략할 수 있다.
  * 클로저에 단 한 줄의 포현만 들어있다면 암시적으로 이를 반환 값으로 취급한다.
  * 축약된 전달인자 이름을 사용할 수 있다.
  * 후행 클로저 문법을 사용할 수 있다.

<br><br>

## 1. 기본 클로저

```swift
/*
public func sorted(by areInIncreasingOrder: (Element, Element -> Bool) -> [Element]
*/

let names: [String] = ["wizplan", "erice", "yagom", "jenny"]

// 정렬을 위한 함수 전달
func backwards(first: String, second: String) -> Bool {
    print("\(first) \(second) 비교중")
    return first > second
}
let reversed: [String] = names.sorted(by: backwards)
print(reversed)

// backward(frist:second:) 함수 대신에 sorted 메서드의 전달인자로 클로저를 직접 전달한다
let reversed2: [String] = names.sorted(by: { (first: String, second: String) -> Bool in
    return first > second
})
print(reversed)
```

<br><br>

## 2. 후행 클로저(Trailing Closure)

* 함수나 메서드의 마지막 전달인자로 위치하는 클로저는 함수나 메서드의 소괄호를 닫은 후 작성해도 된다.
* 클로저가 길어지거나 가독성이 떨어질때 사용
* 전달인자로 여러 개를 전달할 때는 마지막 클로저만 후행 클로저로 사용할 수 있다.
* sorted(by: ) 메서드처럼 하나의 클로저만 전달인자로 전달하는 경우에는 소괄호 생략 가능

```swift
let names: [String] = ["wizplan", "erice", "yagom", "jenny"]

// 후행 클로저의 사용
let reversed: [String] = names.sorted() { (first: String, second: String) -> Bool in
    return first > second
}

// 다중 후행 클로저 사용
doSomething { (someString: String) in
    // do closure
} onSuccess: { (result: Any) in
    // success closure
} onFailure: { (error: Error) in
    // failure closure
}
```

<br><br>

## 3. 클로저 표현 간소화

<br><br>

### 3.1. 문맥을 이용한 타입 유추
* 매개변수의 타입이나 개수, 반환 타입 등이 같아야 전달인자로서 전달할 수 있다. 
  * 전달인자로 전달할 클로저는 이미 적합한 타입을 준수하고 있다고 유추할 수 있다.
  * 전달인자로 전달하는 클로저를 구현할 때는 매개변수의 타입이나 반환 값의 타입을 굳이 표현해주지 않고 생략가능
  
```swift
  let reversed: [String] = names.sorted { (first, second) in
    return first > second
}
```

<br><br>

### 3.2. 단축 인자 이름
* 단축 인자 이름은 첫 번째 전달인자 부터 $0, $1, $2 ... 으로 표현
* in 생략

```swift 
// 단축 인자 이름을 사용한 표현
let reversed: [String] = names.sroted {
    return $0 > $1
}
```

<br><br>

### 3.3 암시적 반환 표현
* 클로저가 반환 값을 갖는 클로저이고 클로저 내부 실행문이 한 줄이라면 return 키워드 생략

```swift
// 암시적 반환 표현의 사용
let reversed: [String] = names.sorted { $0 > $1 }
```

<br><br>

### 3.4. 연산자 함수

```swift
// public func ><T: Comparable>(lhs: T, rhs: T) -> Bool

// 연산자 함수를 클로저의 역할로 사용
let reversed: [String] = names.sorted(by: >)
```

## 4. 값 획득
* 클로저는 자신이 정의된 위치와 주변 문맥을 통해 상수나 변수를 획득(Capture)할 수 있다.
* 값 획득을 통해 클로저는 주변에 정의한 상수나 변수가 더 이상 존재하지 않더라도 해당 상수나 변수의 값을 자신 내부에서 참조하거나 수정할 수 있다.
  * 클로저가 비동기 작업에 많이 사용된다.
  * 클로저를 통해 비동기 콜백(Call-back)을 작성하는 경우, 현재 상태를 미리 획득해두지 않으면 ,실제로 클로저의 기능을 실행하는 순간에는 주변의 상수나 변수가 이미 메모리에 존재하지  않는 경우가 발생한다.
* 중첩 함수도 하나의 클로저 형태이다.
  * 이 중첩 함수 주변의 변수나 상수를 획득해 놓을 수도 있다.
  * 자신을 포함하는 함수의 지역변수나 지역상수를 획득할 수 있다.

<br><br>

* incrementer라는 함수를 중첩 함수로 포함하는 makeIncrementer 함수
  * incrementer() 함수는 자신 주변에 있는 runningTotal과 amount라는 두 값을 획득 후 incremeneter는 클로저로서 makeIncrementer 함수에 의해 반환된다.

```swift
func makeIncrementer(forIncrement amount: Int) -> (() -> Int) {
    var runningTotal = 0
    func incrementer() -> Int {
        runningTotal += amount
        return runningTotal
    }
    return incrementer
}
```
* makeIncrementer 함수의 반환 타입은 () -> Int이다.(**함수객체**를 반환한다는 의미) 
* runningTotal: incrementer가 반환하게 될 값을 저장하는 용도
* incrementer() 함수는 호출될 때마다 amount의 값만큼 runningTotal에 더하여 결괏값을 반환

<br><br>

* incrementByTwo를 호출할 때마다 runningTotal은 값이 2씩 증가
* 각각의 incrementer 함수는 언제 호출이 되더라도 자신만의 runningTotal 변수를 갖고 카운트하게 된다. 자신만의 runningTotal의 참조를 미리 획득해 다른 함수의 영향을 받지 않는다.

<br><br>

## 5. 클로저는 참조 타입

* 위 코드에서 incrementByTwo와 incrementByTen은 모두 상수이다.
* 두 상수 클로저는 값 획득을 통해 runningTotal 변수를 계속해서 증가시킬 수 있다.
  * 함수와 클로저는 참조 타입이기 때문
* 함수나 클로저를 상수나 변수에 할당할 때마다 사실은 상수나 변수에 함수나 클로저의 참조를 설정하는 것이다.
  * 클로저의 참조를 다른 상수에 할당해준다면 이는 두 상수가 모두 같은 클로저를 가리킨다

```swift
let first: Int = incrementByTwo()           // 2
let second: Int = sameWithIncrementByTwo()  // 4
```
* 두 상수는 같은 클로저를 참조하기 때문에 동일한 클로저가 동작하는 것을 확인할 수 있다.

<br><br>

## 6. 탈출 클로저
* 함수의 전달인자로 전달한 클로저가 함수 종료 후에 호출될 때 클로저가 함수를 탈출(Escape)한다고 표현한다.
* @escaping 키워드를 사용해 클로저가 탈출하는 것을 허용한다고 명시해 준다.
* 컴플리션 핸들러(Completion handler): 비동기 작업을 실행하는 함수들은 클로저를 컴플리션 핸들러 전달인자로 받아온다.
* 비동기 작업으로 함수가 종료되고 난 후 호출할 필요가 있는 클로저를 사용해야 할 때 탈출 클로저(Escaping Closure)가 필요하다.
* 함수 외부에 정의된 변수나 상수에 저장되어 함수가 종료된 후에 사용할 경우
  * 비동기로 작업을 하기위해 컴플리션 핸들러를 전달인자를 이용해 클로저 형태로 받는 함수들
  * 함수가 작업을 종료하고 난 이후에 컴플리션 핸들러, 즉 클로저를 호출하기 떄문에 클로저는 함수를 탈출해 있어야만 한다.
* 함수의 전달인자로 전달받은 클로저를 다시 반환할 떄도 마찬가지이다.

```swift
var completionHandlers: [() -> Void] = []

func someFunctionWithEscapingClosure(completionHandler: @escaping () -> Void) {
    completionHandlers.append(completionHandler)
}
```

<br>

```swift
typealias VoidVoidClosure = () -> Void
let firstClosure: VoidVoidClosure = {
    print("Closure A")
}
let secondClosure: VoidVoidClosure = {
    print("Closure B")
}

// first와 second 매개변수 클로저는 함수의 반환 값으로 사용될 수 있으므로 탈출 클로저이다.
func returnOneClosure(first: @escaping VoidVoidClosure, second: @escaping VoidVoidClosure, shouldReturnFirstClosure: Bool) -> VoidVoidClosure {
    // 전달인자로 전달받은 클로저를 함수 외부로 다시 반환하기 때문에 함수를 탈출하는 클로저이다.
    return shouldReturnFirstClosure ? first : second
}

// 함수에서 반환한 클로저가 함수 외부의 상수에 저장되었습니다.
let returnedClosure: VoidVoidClosure = returnOneClosure(
    first: firstClosure,
    second: secondClosure,
    shouldReturnFirstClosure: true
)

returnedClosure()   // Closure A

var closures: [VoidVoidClosure] = []

// closure 매개변수 클로저는 함수 외부의 변수에 저장될 수 있으므로 탈출 클로저이다.
func appendClosure(closure: @escaping VoidVoidClosure) {
    // 전달인자로 전달받은 클로저가 함수 외부의 변수 내부에 저장되므로 함수를 탈출한다.
    closures.append(closure)
}
```

* 이 코드는 클로저 모두가 탈출할 수 있는 조건이 명확하기 때문에 `@escaping` 키워드를 사용하지 않으면 컴파일 오류가 발생한다.
* 타입 내부 메서드의 매개변수 클로저에 @escaping 키워드를 사용하여 탈출 클로저임을 명시한 경우, 클로저 내부에서 해당 타입의 프로퍼티나 메서드, 서브스크립트 등에 접근하려면 self 키워드를 명시적으로 사용해야 한다.
* 비탈출 클로저는 self 키워드를 꼭 써주지 않아도 된다.

```swift
typealias VoidVoidClosure = () -> Void
func functionWithNoescapeClosure(closure: VoidVoidClosure) {
    closure()
}

func functionWithEscapingClosure(
    completionHandler: @escaping VoidVoidClosure
    ) -> VoidVoidClosure {
    
    return completionHandler
    }

class SomeClass {
    var x = 10
    
    func runNoescapeClosure() {
        // 비탈출 클로저에서 self 키워드 사용은 선택 사항
        functionWithNoescapeClosure { x = 200 }
    }
    
    func runEscapingClosure() -> VoidVoidClosure {
        // 탈출 클로저에서는 명시적으로 self를 사용해야 합니다.
        return functionWithEscapingClosure { self.x = 100 }
    }
}

let instance: SomeClass = SomeClass()
instance.runNoescapeClosure()
print(instance.x)   // 200

let returnedClosure: VoidVoidClosure = instance.runEscapingClosure()
returnedClosure()
print(instance.x)   // 100
```

<br><br>

### 6.1. withoutActuallyEscaping

* 비탈출 클로저로 전달한 클로저가 탈출 클로저인 척 해야 하는 경우 애매하다.
  * 실제로는 탈출하지 않는데 다른 함수에서 탈출 클로저를 요구하는 상황

<br>

hasElements(in:match:)는 in 매개변수로 검사할 배열을 전달받으며, match라는 매개변수로 검사를 실행할 클로저를 받아들인다. @escaping 키워드가 없으므로 비탈출 클로저를 전달받는다. 그리고 배열의 lazy 컬렉션에 있는 filter 메서드의 매개변수로 비탈출 클로저를 전달한다. lazy 컬렉션은 비동기 작업을 할 때 사용하기 떄문에 filter 메서드가 요구하는 클로저는 탈출 클로저이다. 그래서 탈출 클로저 자리에 비탈출 클로저를 전달할 수 없다는 오류가 발생한다

```swift
func hasElements(in array: [Int], match predicate: (Int) -> Bool) -> Bool {
    return (array.lazy.filter { predicate($0) }.isEmpty == false)
}
```

<br><br>

함수 전체를 보면, match 클로저가 탈출할 필요가 없다. 이때 해당 클로저를 탈출 클로저인양 사용할 수 있게 돕는 withoutActuallyEscaping(_:do:) 함수가 있다.

```swift
let numbers: [Int] = [2, 4, 6, 8]

let evenNumberPredicate = { (number: Int) -> Bool in
    return number % 2 == 0
}

let oddNumberPredicate = { (number: Int) -> Bool in
    return number % 2 == 1
}

func hasElements(in array: [Int], match predicate: (Int) -> Bool) -> Bool {
    return withoutActuallyEscaping(predicate, do: { escapablePredicate in
        return (array.lazy.filter { escapablePredicate($0) }.isEmpty == false)
    })
}

let hasEvenNumber = hasElements(in: numbers, match: evenNumberPredicate)
let hasOddNumber = hasElements(in: numbers, match: oddNumberPredicate)

print(hasEvenNumber)    // true
print(hasOddNumber)     // false
```
* 함수의 첫 번째 전달인자로 탈출 클로저인 척해야 하는 클로저가 전달
* do 전달인자는 이 비탈출 클로저를 또 매개변수로 전달받아 실제로 작업을 실행할 탈출 클로저를 전달한다.

<br><br>

## 7. 자동 클로저(Auto Closure)

<br>

* 자동 클로저(Auto Closure): 함수의 전달인자로 전달하는 표현을 자동을 변환해주는 클로저
* 자동 클로저는 전달인자를 갖지 않는다.
* 자동 클로저는 호출되었을 떄 자신이 감싸고 있는 코드의 결괏값을 반환한다.
* 자동 클로저는 클로저가 호출되기 전까지 콜로저 내부의 코드가 동작하지 않는다. -> 연산을 지연시킬 수 있다.
  
```swift
// 대기 중인 손님들입니다.
var customersInLine: [String] = ["YoangWha", "SangYong", "SungHun", "HaMi"]
print(customersInLine.count)    // 4

// 클로저를 만들어 두면 클로저 내부의 코드를 미리 실행(연산) 하지 않고 가지고만 있습니다.
let customerProvider: () -> String = {
    return customersInLine.removeFirst()
}
print(customersInLine.count)    // 4

// 실제로 실행
print("Now serving \(customerProvider())!")     // Now serving YoangWha!
print(customersInLine.count)    // 3
```

```swift
var customersInLine: [String] = ["YoangWha", "SangYong", "SungHun", "HaMi"]

func serveCustomer(_ customerProvider: () -> String) {
    print("Now serving \(customerProvider())!")
}

serveCustomer( { customersInLine.removeFirst() })   // Now serving YoangWha!

```

```swift
var customersInLine: [String] = ["YoangWha", "SangYong", "SungHun", "HaMi"]

func serveCustomer(_ customerProvider: @autoclosure () -> String) {
    print("Now serving \(customerProvider())!")
}

serveCustomer(customersInLine.removeFirst())    // Now serving YoangWha!
```
serveCustomer(_:) 함수에 `@autoclosure`속성을 줘 자동 클로저로 사용 한다. 자동 클로저 속성을 부여한 매개변수는 클로저 대신에 reomoveFirst() 코드의 실행 결과인 String 타입의 문자열을 전달인자로 받게 된다. String 타입의 값이 자동 클로저 매개변수에 전달되면 String 값을 매개변수가 없는 String 값을 반환하는 클로저로 변환해준다.  <br>
자동 클로저를 사용하면 기존의 사용 방법처럼 클로저를 전달인자로 넘겨줄 수 없다.



<br>

### 자동클로저의 탈출
* @autoclosure 속성은 @noescape 속성을 포함한다.
* @autoclosure @escaping 자동 클로저를 탈출하는 클로저로 사용가능

```swift
var customersInLine: [String] = ["minjae", "innoveive", "sopress"]

func returnProvider(_ customerProvider: @autoclosure @escaping () ->
    String) -> (() -> String) {
    return customerProvider
}
let customerProvider: () -> String = returnProvider(customersInLine.removeFirst())
print("Now serving \(customerProvider())!")     // Now serving minjae!
```
# 프로퍼티와 메서드

* 프로퍼티: 클래스, 구조체 또는 열거형 등에 관련된 값
* 메서드: 특정 타입에 관련되 함수

</br>

## 1. 프로퍼티
* 저장 프로퍼티(Stored Properties): 인스턴스의 변수 또는 상수를 의미
* 연산 프로퍼티(Computed Properties): 값을 저장한 것이 아니라 특정 연산을 실행한 결괏값을 의미
  * 클래스, 구조체, 열거형에 쓰일 수 있다.
* 타입 프로퍼티(Type Properties): 저장, 연산 프로퍼티는 특정 타입의 인스턴스에 사용되는 것을 뜻하지만 타입 프로퍼티는 특정 타입에 사용된다.
* 프로퍼티 감시자(Property Observers): 프로퍼티의 값이 변하는 것을 감시한다. 프로퍼티의 값이 변할 때 값의 변화에 따른 특정 작업을 실행한다.
  * 저장 프로퍼티에 적용가능, 부모클래스로부터 상속받을 수 있다.

</br>

### 1.1. 저장 프로퍼티
* 클래스, 구조체, 인스턴스와 연관된 값을 저장하는 가장 단순한 개념의 프로퍼티
* 저장 프로퍼티를 정의할 때 프로퍼티 기본값과 초깃값을 지정해줄 수 있다.

</br>

> * 구조체의 저장 프로퍼티가 옵셔널이 아니더라도, 구조체는 저장 프로퍼티를 모두 포함하는 이니셜라이저를 자동으로 생성
> * 클래스의 저장 프로퍼티는 옵셔널이 아니라면 프로퍼티 기본값을 지정해주거나 사용자의 정의 이니셜라이저를 통해 반드시 초기화해주어야 한다.
> * 클래스 인스턴스의 상수 프로퍼티는 인스턴스가 이니셜라이즈될 때 한 번만 값 할당가능, 자식클래스에서 이 초기화를 변경(재정의)할 수 없다.


```swift
// 좌표
struct CoordinatePoint {
    var x: Int      // 저장 프로퍼티
    var y: Int      // 저장 프로퍼티
}

// 구조체에는 기본적으로 저장 프로퍼티를 매개변수로 갖는 이니셜라이저가 있다.
let hoonPoint: CoordinatePoint = CoordinatePoint(x: 10, y: 5)

// 사람의 위치 정보
class Position {
    var point: CoordinatePoint
    // 저장 프로퍼티(변수) - 위치(point)는 변경될 수 있음을 뜻한다.
    let name:  String       // 저장 프로퍼티 (상수)
    
    // 프로퍼티 기본값을 지정해주지 않으면 이니셜라이저를 따로 정의해주어야 한다.
    init(name: String, currentPorint: CoordinatePoint) {
        self.name = name
        self.point = currentPorint
    }
}

// 사용자 정의 이니셜라이저를 호출해야만 합니다
// 그렇지 않으면 프로퍼티 초깃값을 할당할 수 없기때문에 인스턴스 생성이 불가능하다
let hoonPosition: Position = Position(name: "hoon", currentPorint: hoonPoint)
```

* 클래스의 저장 프로퍼티에 초깃값을 지정해주면 사용자 정의 이니셜라이저 구현 필요 없다.
  * 의도와 맞지 않게 인스턴스가 사용될 가능성이 있고, 생성후 일일이 할당해야 해서 불편하다.
  * name프로퍼티는 상수로 정의하고 싶어도 생성한 후에 값을 할당해 주어야 하기

```swift
// 좌표
struct CoordinatePoint {
    var x: Int = 0      // 저장 프로퍼티
    var y: Int = 0      // 저장 프로퍼티
}

// 프로퍼티의 초깃값을 할당했다면 굳이 전달인자로 초깃값을 넘길 필요가 없다.
let hoonPoint: CoordinatePoint = CoordinatePoint()

// 이니셜라이저도 사용 가능
let wizplanPoint: CoordinatePoint = CoordinatePoint(x: 10, y: 5)

print("hoon's Point : \(hoonPoint.x), \(hoonPoint.y)")

// 사람의 위치 정보
class Position {
    var point: CoordinatePoint = CoordinatePoint()  // 저장
    var name:  String = "Unknown"
}

// 초깃값을 지정해줬다면 사용자 정의 이니셜라이저를 사용하지 않아도 됩니다.
let hoonPosition: Position = Position()

hoonPosition.point = hoonPoint
hoonPosition.name = "hoon"
```

* 인스턴스를 생성할 때 이니셜라이저를 통해 초깃값을 보내야 하는 이유는 프로퍼티가 옵셔널이 아닌 값으로 선언되어 있기 때문이다.
* 이니셜라이저에서 옵셔널 프로퍼티에 꼭 값을 할당해주지 않아도 된다.

```swift
// 좌표
struct CoordinatePoint {
    // 위치는 x, y 값이 모두 있어야 하므로 욥셔널이면 안 됩니다.
    var x: Int = 0
    var y: Int = 0
}



// 사람의 위치 정보
class Position {
    // 현재 사람의 위치를 모를 수도 있다. - 옵셔널
    var point: CoordinatePoint?
    let name:  String
    
    init(name: String) {
        self.name = name
    }
}

// 이름은 필수지만 위치는 몰를 수 있습니다.
let hoonPosition: Position = Position(name: "hoon")

// 위치를 알게되면 그 떄 위치 값을 할당해준다.
hoonPosition.point = CoordinatePoint(x: 20, y: 10)
```

### 1.2. 지연 저장 프로퍼티
* 지연 저장 프로퍼티(Lazy Stored Properties): 호출이 있어야 값을 초기화한다.
* lazy 키워드 사용
* 상수는 인스턴스가 완전히 생성되기 전에 초기화해야 하므로 var 키워드를 사용하여 정의한다.
* 복잡한 클래스나 구조체 구현할때 사용
  * 클래스 인스턴스의 저장 프로퍼티로 다른 클래스 인스턴스나 구조체 인스턴스를 할당해야 할때

```swift
// 좌표
struct CoordinatePoint {
    // 위치는 x, y 값이 모두 있어야 하므로 욥셔널이면 안 됩니다.
    var x: Int = 0
    var y: Int = 0
}

// 사람의 위치 정보
class Position {
    // 현재 사람의 위치를 모를 수도 있다. - 옵셔널
    lazy var point: CoordinatePoint = CoordinatePoint()
    let name:  String
    
    init(name: String) {
        self.name = name
    }
}

let hoonPosition: Position = Position(name: "hoon")

// 이 코드를 통해 point 프로퍼티로 처음 접근할 때
// point 프로퍼티의 CoordinatePoint가 생성됩니다.
print(hoonPosition.point)   // CoordinatePoint(x: 0, y: 0)
```

> **다중 스레드와 지연저장 프로퍼티**
> 다중 스레드 환경에서 지연 저장 프로퍼티에 동시에 접근할때 생성되지 않은 지연 저장 프로퍼티에 많은 스레드가 비슷한 시점에 접근한다면, 여러 번 초기화될 수 있다.

</br>

### 1.3. 연산 프로퍼티
* 특정 상태에 따른 값을 연산하는 프로퍼티
* getter(접근자): 인스턴스 내/외부의 값을 연산하여 적절한 값을 돌려준다.
* setter(설정자): 은닉화된 내부의 프로퍼티 값을 간접적으로 설정한다.
* 클래스, 구조체, 열거형에서 연산 프로퍼티를 정의할 수 있다.
* 메서드를 통해 구현했을때 보다 가독성 증가
* 연산 프로퍼티는 읽기 전용 상태로 구현하기 쉽지만, 쓰기 전용 상태로 구현할 수 없다는 단점이 있다.
* 메서드로는 설정자 메서드만 구현해 쓰기 전용 상태로 구현할 수 있지만 연산 프로퍼티는 불가능하다.

```swift
// 메서드로 구현된 접근자와 설정자

struct CoordinatePoint {
    var x: Int      // 저장 프로퍼티
    var y: Int      // 저장 프로퍼티
    
    // 대칭점을 구하는 매서드 - 접근자
    // Self는 타입 자기 자신을 뜻합니다
    // Self 대신 CoordinatePoint를 사용해도 됩니다.
    func oppositePorint() -> Self {
        return CoordinatePoint(x: -x, y: -y)
    }
    
    // 대칭점을 설정하는 메서드 - 설정자
    mutating func setOppositePoint(_ opposite: CoordinatePoint) {
        x = -opposite.x
        y = -opposite.y
    }
}

var hoonPosition: CoordinatePoint = CoordinatePoint(x: 10, y: 20)

// 현재 좌표
print(hoonPosition)                         // CoordinatePoint(x: 10, y: 20)


// 대칭 좌표
print(hoonPosition.oppositePorint())        // CoordinatePoint(x: -10, y: -20)


// 대칭 좌표를 (15, 10)으로 설정
hoonPosition.setOppositePoint(CoordinatePoint(x: 15, y: 10))

// 현재 좌표
print(hoonPosition)                         // CoordinatePoint(x: -15, y: -10)
```

> oppositePoint() 메서드로 대칭점을 구할 수 있으며 setOppositePoint(_:) 메서드로 대칭점을 설정해줘야 한다. 접근자와 설정자의 일관성을 유지하기 힘들고 가독성도 떨어진다. 


</br>


```swift
// 연산 프로퍼티 정의와 사용

struct CoordinatePoint {
    var x: Int      // 저장 프로퍼티
    var y: Int      // 저장 프로퍼티

    // 대칭 좌표
    var oppositePoint: CoordinatePoint{     // 연산 프로퍼티
        // 접근자
        get {
            return CoordinatePoint(x: -x, y: -y)
        }
        
        // 설정자
        set(opposite) {
            x = -opposite.x
            y = -opposite.y
        }
    }
}

var hoonPosition: CoordinatePoint = CoordinatePoint(x: 10, y: 20)

// 현재 좌표
print(hoonPosition)                     // CoordinatePoint(x: 10, y: 20)

// 대칭좌표 - 접근자 사용
print(hoonPosition.oppositePoint)       // CoordinatePoint(x: -10, y: -20)

// 설정자 사용
hoonPosition.oppositePoint = CoordinatePoint(x: 15, y: 10)
print(hoonPosition)                     // CoordinatePoint(x: -15, y: -10)
```

* 하나의 프로퍼티에 접근자와 설정자가 모두 모여있고 가독성이 좋다.
* 마치 저장 프로퍼티인 것처럼 사용할수 있다.

</br>

* 설정자의 매개변수를 소괄호 안에 명시해주면 set 메서드 내부에서 전달받은 전달인자를 사용할 수 있다.
  * 매개변수 표기 안하면 관용적인 표현으로 newValue로 매개변수 이름을 대신한다.
* 접근자 내부 코드가 한 줄이고 결괏값의 타입이 프로퍼티의 타입과 같다면 return 생략 가능

```swift
// 매개변수이름, return 키워드 생략

struct CoordinatePoint {
    var x: Int      // 저장 프로퍼티
    var y: Int      // 저장 프로퍼티

    // 대칭 좌표
    var oppositePoint: CoordinatePoint{     // 연산 프로퍼티
        // 접근자
        get {
            CoordinatePoint(x: -x, y: -y)
        }
        
        // 설정자
        set {
            x = -newValue.x
            y = -newValue.y
        }
    }
}
```

</br>

* 읽기 전용 

```swift
struct CoordinatePoint {
    var x: Int      // 저장 프로퍼티
    var y: Int      // 저장 프로퍼티

    // 대칭 좌표
    var oppositePoint: CoordinatePoint{     // 연산 프로퍼티
        // 접근자
        get {
            CoordinatePoint(x: -x, y: -y)
        }
    }
}

var hoonPosition: CoordinatePoint = CoordinatePoint(x: 10, y: 20)

// 현재 좌표
print(hoonPosition)                     // CoordinatePoint(x: 10, y: 20)

// 대칭좌표
print(hoonPosition.oppositePoint)       // CoordinatePoint(x: -10, y: -20)

// 설정자를 구현하지 않았으므로 오류!!
hoonPosition.oppositePoint = CoordinatePoint(x: 15, y: 10)
```

</br>

### 1.4. 프로퍼티 감시자

* 프로퍼티 감시자(Property Observers)를 사용하면 프로퍼티의 값이 변경됨에 따라 적절한 작업을 할 수 있다.
* 프로퍼티의 값이 새로 할당될 때마다 호출한다. ( 변경되는 값이 현재의 값과 같더라도 호출)
* 저장 프로퍼티뿐만 아니라 프로퍼티를 재정의해 상속받은 저장 프로퍼티 또는 연산 프로퍼티에도 적용할 수 있다.
  * 상속 받지 않은 연산프로퍼티에는 감시자를 사용할 필요가 없으며 할 수도 없다.
  * 연산 프로퍼티의 접근자와 설정자를 통해 감시자를 구현
* willSet 메서드: **변경될 값**이 전달인자로 전달
  * 매개변수 이름 미정의시 newValue 사용
* didSet 메서드: **변경되기 전의 값**이 전달인자로 전달
  * 매개변수 이름 미정의시 oldValue 사용
* didSet 감시자 코드 블록 내부에서 oldValue값을 참조하지 않거나 매개변수를 적어 주지 않으면 didSet블록 실행되지 않는다.


```swift
class Account {
    var credit: Int = 0 {
        willSet {
            print("잔액이 \(credit)원에서 \(newValue)원으로 변경될 예정입니다.")
        }
        
        didSet {
            print("잔액이 \(oldValue)원에서 \(credit)원으로 변경되었습니다.")
        }
    }
}

let myAccount: Account = Account()
// 잔액이 0원에서 1000원으로 변경될 예정입니다.

myAccount.credit = 1000
// 잔액이 0원에서 1000원으로 변경되었습니다.
```

* 클래스를 상속받았다면 기존의 연산 프로퍼티를 재정의해 프로퍼티 감시자를 구현할 수도있다. 연산 프로퍼티를 재정의해도 기존의 연산 프로퍼티 기능(접근자와 설정자, get과 set메서드는 동작한다.)


```swift
class Account {
    var credit: Int = 0 {
        willSet {
            print("잔액이 \(credit)원에서 \(newValue)원으로 변경될 예정입니다.")
        }
        
        didSet {
            print("잔액이 \(oldValue)원에서 \(credit)원으로 변경되었습니다.")
        }
    }
    
    var dollarValue: Double {   // 연산 프로퍼티
        get {
            return Double(credit) / 1000.0
        }
        set {
            credit = Int(newValue * 1000)
            print("잔액을 \(newValue)달러로 변경 중입니다.")
        }
    }
}

class ForeignAccount: Account {
    override var dollarValue: Double {
        willSet {
            print("잔액이 \(dollarValue)달러에서 \(newValue)달러로 변경될 예정입니다.")
        }
        
        didSet {
            print("잔액이 \(oldValue)달러에서 \(dollarValue)달러로 변경되었습니다.")
        }
    }
}


let myAccount: ForeignAccount = ForeignAccount()
// 잔액이 0원에서 1000원으로 변경될 예정입니다.

myAccount.credit = 1000
// 잔액이 0원에서 1000원으로 변경되었습니다.

// 잔액이 1.0달러에서 2.0달러로 변경될 예정입니다.
// 잔액이 1000원에서 2000원으로 변경될 예정입니다.
// 잔액이 1000원에서 2000원으로 변경 되었습니다.

myAccount.dollarValue = 2   // 잔액을 2.0달러로 변경 중입니다.
// 잔액이 1.0달러에서 2.0달러로 변경되었습니다.
```

</br>

### 1.5. 전역변수와 지역변수

* 연산 프로퍼티와 프로퍼티 감시자는 전역변수와 지역변수 모두에 사용할수있다.
* 저장변수: 변수라고 통칭했던 전역변수 또는 지역변수
  * 연산변수로 구현할 수도 있으며, 프로퍼티 감시자를 구현할 수도 있습니다
  * 전역변수, 전역상수는 지역 저장 프로퍼티 처럼 처음 접근할 때 최초로 연산이 이루어진다. lazy 키워드를 사용할 필요 없다.
  * 지역변수, 지역상수는 절대로 지연 연산되지 않는다.

</br>

### 1.6. 타입 프로퍼티

* 타입 프로퍼티: 각각의 인스턴스가 아닌 타입 자체에 속하는 프로퍼티
* 타입 자체에 영향을 미치는 프로퍼티
* 인스턴스의 생성 여부와 상관없이 타입 프로퍼티의 값은 하나이고 그 타입의 모든 인스턴스가 공통으로 사용하는 값(static constant와 유사)
* 모든 인스턴스가 공용으로 접근하고 값을 변경할 수 있는 변수(static 변수와 유사)

</br>

* 저장 타입 프로퍼티: 변수 또는 상수로 선언할 수 있고, 반드시 초깃값을 설정해야 하며 지연 연산된다.(lazy 사용 X)
  * 지연 저장 프로퍼티와는 다르게 다중 스레드 환경이라고 해도 단 한 번만 초기화 된다.
* 연산 타입 프로퍼티: 변수로만 선언할 수 있다
* 타입 프로퍼티는 인스턴스를 생성하지 않고도 사용할 수 있다.

```swift
class AClass {
    
    // 저장 타입 프로퍼티
    static var typeProperty: Int = 0
    
    // 저장 인스턴스 프로퍼티
    var instanceProperty: Int = 0 {
        didSet {
            // Self.typeProperty는
            // AClass.typeProperty와 같은 표현입니다.
            Self.typeProperty = instanceProperty + 100
        }
    }
    
    // 연산 타입 프로퍼티
    static var typeComputedProperty: Int {
        get {
            return typeProperty
        } set {
            typeProperty = newValue
        }
    }
}

AClass.typeProperty = 123

let classInstance: AClass = AClass()
classInstance.instanceProperty = 100

print(AClass.typeProperty)          // 200
print(AClass.typeComputedProperty)  // 200
```

* 타입 프로퍼티를 타입 상수로 사용

```swift
class Account {
    
    static let dollarExchangeRate: Double = 1000.0      // 타입 상수
    
    var credit: Int = 0         // 저장 인스턴스 프로퍼티
    
    var dollarValue: Double {   // 연산 인스턴스 프로퍼티
        get {
            return Double(credit)
        }
        
        set {
            credit = Int(newValue * Account.dollarExchangeRate)
            print("잔액을 \(newValue)달러로 변경 중입니다.")
        }
    }
}
```

</br>

### 1.7. 키 경로

* 상수나 변수에 참조를 할당할 수 있다.

```swift
func someFunction(paramA: Any, paramB: Any) {
    print("someFunction called...")
}

var functionReference = someFunction(paramA:paramB:)
```

* 나중에 호출, 다른 함수를 참조하도록 할 수도 있다.

```swift
func someFunction(paramA: Any, paramB: Any) {
    print("someFunction called...")
}

func anotherFunction(paramA: Any, paramB: Any) {
    print("anotherFunction called...")
}

var functionReference = someFunction(paramA:paramB:)

functionReference("A", "B")
functionReference = anotherFunction(paramA:paramB:)
```

* 키 경로(keyPath): 값을 바로 꺼내오는 것이 아니라 어떤 **프로퍼티 위치**만 참조하도록 할 수 있다.
* 간접적으로 특정 타입의 어떤 프로퍼티 값을 가리켜야 할지 미리 지정해두고 사용할 수 있다.


```swift
class Person {
    var name: String
    
    init(name: String) {
        self.name = name
    }
}

struct Stuff {
    var name: String
    var owner: Person
}

print(type(of: \Person.name))   // ReferenceWritableKeyPath<Person, String>
print(type(of: \Stuff.name))    // WritableKeyPath<Stuff, String>

// 키 경로 타입의 경로 연결
let keyPath = \Stuff.owner
let nameKeyPath = keyPath.appending(path: \.name)
```

* 서브스크립트와 키 경로 활용

```swift
class Person {
    let name: String
    init(name: String) {
        self.name = name
    }
}

struct Stuff {
    var name: String
    var owner: Person
}

let yagom = Person(name: "yagom")
let hana = Person(name: "hana")
let macbook = Stuff(name: "MacBook Pro", owner: yagom)
var iMac = Stuff(name: "iMac", owner: yagom)
let iPhone = Stuff(name: "iPhone", owner: hana)

let stuffNameKeyPath = \Stuff.name
let ownerkeyPath = \Stuff.owner

// \Stuff.owner.name와 같은 표현이다
let ownerNameKeyPath = ownerkeyPath.appending(path: \.name)

// 키 경로와 서브스크립트를 이용해 프로퍼티에 접근하여 값을 가져온다
print(macbook[keyPath: stuffNameKeyPath])
print(iMac[keyPath: stuffNameKeyPath])
print(iPhone[keyPath: stuffNameKeyPath])

print(macbook[keyPath: ownerNameKeyPath])
print(iMac[keyPath: ownerNameKeyPath])
print(iPhone[keyPath: ownerNameKeyPath])

// 키 경로와 서브스크립트를 이용해 프로퍼티에 접근하여 값을 변경한다.
iMac[keyPath: stuffNameKeyPath] = "iMac Pro"
iMac[keyPath: ownerkeyPath] = hana

print(iMac[keyPath: stuffNameKeyPath])
print(iMac[keyPath: ownerNameKeyPath])

// 상수로 지정한 값 타입과 읽기 전용 프로퍼티는 키 경로 서브스크립트로도 값을 바꿔줄 수 없다.
// macbook[keyPath: stuffNameKeyPath] = "macbook pro touch bar"    // 오류 발생!
// yagom[keyPath: \Person.name] = "bear"                           // 오류 발생!
```

* 키 경로를 잘 활용하면 프로토콜과 마찬가지로 타입 간의 의존성을 낮추는 데 많은 도움을 준다
* 키 경로 타입 외부로 공개된 **인스턴스 프로퍼티 혹은 서브스크립트에** 한하여 표현할 수 있다.
* 자신을 나타내는 \.Self를 사용하면 인스턴스 그 자체를 표현하는 키 경로가 된다. 컴파일러가 타입을 유추할 수 있는 경우에는 키 경로에서 타입 이름을 생략할 수도 있다.

</br>

* 클로저를 대체할 수 있는 키 경로 표현

```swift
struct Person {
    let name: String
    let nickname:  String?
    let age: Int
    
    var isAdult: Bool {
        return age > 18
    }
}

let yagom: Person = Person(name: "yagom", nickname: "bear", age: 100)
let hana: Person = Person(name: "hana", nickname: "na", age: 100)
let happy: Person = Person(name: "happy", nickname: nil, age: 3)

let family: [Person] = [yagom, hana, happy]
let names: [String] = family.map(\.name)    // ["yagom", "hana", "happy"]
let nicknames: [String] = family.compactMap(\.nickname)     // ["bear", "na"]
let adults: [String] = family.filter(\.isAdult).map(\.name) // ["yagom", "hana"]
```

## 2. 메서드
> 메서드는 특정 타입에 관련된 함수를 뜻한다. 구조체와 열거형이 메서드를 가질 수 있다는 것은 기존프로그래밍 언어와 스위프트간의 큰 차이점이다.

</br>

### 2.1. 인스턴스 메서드
* 인스턴스 메서드는 특정 타입의 인스턴스에 속한 함수를 뜻한다.


```swift
class LevelClass {
    // 현재 레벨을 저장하는 저장 프로퍼티
    var level: Int = 0 {
        // 프로퍼티 값이 변경되면 호출하는 프로퍼티 감시자
        didSet {
            print("Level \(level)")
        }
    }
    
    // 레벨이 올랐을 떄 호출할 메서드
    func levelUp() {
        print("Level Up!")
        level += 1
    }
    
    // 레벨이 감소했을 때 호출할 메서드
    func levelDown() {
        print("Level Down")
        level -= 1
        if level < 0 {
            reset()
        }
    }
    
    // 특정 레벨로 이동할 때 호출할 메서드
    func jumpLevel(to: Int) {
        print("Jump to \(to)")
        level = to
    }
    
    // 레벨을 초기화할 때 호출할 메서드
    func reset() {
        print("Reset")
        level = 0
    }
}

var levelCalssInstance: LevelClass = LevelClass()
levelCalssInstance.levelUp()
// Level 1
levelCalssInstance.levelDown()
// Level 0
levelCalssInstance.levelDown()
// Level -1
// Reset
// Level 0
levelCalssInstance.jumpLevel(to: 3)
// Level 3
```

* mutating: 구조체나 열겨형 등은 자신의 프로퍼티 값을 수정할 클래스의 인스턴스 메서드 앞에 mutating 키워드를 붙여준다. 
  * 클래스는 상관없다.

```swift
struct LevelStruct {
    var level: Int = 0 {
        didSet {
            print("Level \(level)")
        }
    }
    
    mutating func levelUp() {
        print("Level Up!")
        level += 1
    }
    
    
    mutating func levelDown() {
        print("Level Down")
        level -= 1
        if level < 0 {
            reset()
        }
    }
    
    
    mutating func jumpLevel(to: Int) {
        print("Jump to \(to)")
        level = to
    }
    
    
    mutating func reset() {
        print("Reset")
        level = 0
    }
}

var levelStructInstance: LevelClass = LevelClass()
levelStructInstance.levelUp()
// Level 1
levelStructInstance.levelDown()
// Level 0
levelStructInstance.levelDown()
// Level -1
// Reset
// Level 0
levelStructInstance.jumpLevel(to: 3)
// Level 3
```

* self 프로퍼티
  * 모든 인스턴스는 암시적으로 자기 자신을 가리키는 프로퍼티 self를 갖는다.
  * 인스턴스를 더 명확히 지칭하고 싶을 때 사용한다.
  * 값 타입 인스턴스 자체의 값을 치활할 수 있다.(클래스는 X)

```swift
class LevelClass {
    var level: Int = 0
    
    func reset() {
        // 오류! self 프로퍼티 참조 변경 불가능!
//       self = LevelClass()
    }
}

struct LevelStruct {
    var level: Int = 0
    
    mutating func levelUp() {
        print("Level Up!")
        level += 1
    }
    
    mutating func reset() {
        print("Reset!")
        self = LevelStruct()
    }
}

var levelStructInstance: LevelStruct = LevelStruct()
levelStructInstance.levelUp()           // Level Up!
print(levelStructInstance.level)        // 1

levelStructInstance.reset()             // Reset!
print(levelStructInstance.level)        // 0

enum OnOffSwitch {
    case on, off
    mutating func nextState() {
        self = self == .on ? .off : .on
    }
}

var toggle: OnOffSwitch = OnOffSwitch.off
toggle.nextState()
print(toggle)   // on
```

</br>

**인스턴스를 함수처럼 호출하도록 하는 메서드**
* 사용자 정의 명목 타입의 호출 가능한 값(Callable values of user-defined nominal types)을 구현하기 위해 인스턴스를 함수처럼 호출할 수 있도록 하는 메서드(call-as-function method)
* callAsFunction이라는 메서드를 구현하면 된다.
* 매개변수와 반환 타입만 다르면 개수에 제한 없이 원하는 만큼 만들 수 있다.

```swift
struct Puppy {
    var name: String = "멍멍이"
    
    func callAsFunction() {
        print("멍멍")
    }
    
    func callAsFunction(destination: String) {
        print("\(destination)(으)로 달려갑니다")
    }
    
    func callAsFunction(something: String, times: Int) {
        print("\(something)(을)를 \(times)번 반복합니다")
    }
    
    func callAsFunction(color: String) -> String {
        return "\(color) 응가"
    }
    
    mutating func callAsFunction(name: String) {
        self.name = name
    }
}

var doggy: Puppy = Puppy()
doggy.callAsFunction()  // 멍멍
doggy()                 // 멍멍

doggy.callAsFunction(destination: "집")  // 집(으)로 달려갑니다
doggy(destination: "뒷동산")              // 뒷동산(으)로 달려갑니다
doggy(something: "재주넘기", times: 3)     // 재주넘기(을)를 3번 반복합니다
doggy(color: "무지개색")                   // 무지개색 응가
doggy(name: "댕댕이")
print(doggy.name)   // 댕댕이
```

* 함수 표현으로는 사용할 수 없다.


```swift
let function: (String) -> void = doggy(destination:)   // 불가능
let function: (String) -> Void = doggy.callAsFuncTion(destination:) // 가능
```

</br>

### 2.2. 타입 메서드
* 타입 자체에 호출이가능한 메서드
* 메서드 앞에 static 키워드를 사용
* 클래스의 타입메서드 키워드
  * static: 상속 후 메서드 재정의가 불가능하다
  * class: 상속 후 메서드 재정의가 가능하다


```swift
class AClass {
    static func staticTypeMethod() {
        print("AClass staticTypeMethod")
    }
    
    class func classTypeMethod() {
        print("AClass classTypeMethod")
    }
}

class BClass: AClass {
    /*
     // 오류 발생!! 재정의 불가!
     override static func staticTypeMethod() {
     
     }
     */
    override class func classTypeMethod() {
        print("BClass classTypeMethod")
    }
}

AClass.staticTypeMethod()   // AClass staticTypeMethod
AClass.classTypeMethod()    // AClass classTypeMethod
BClass.classTypeMethod()    // BClass classTypeMethod
```

* 인스턴스 메서드와 달리 self프로퍼티가 타입 그 자체를 가리킨다.
  * 타입 메서드 내부에서 타입 이름과 self는 같은 뜻이다.
  * self 프로퍼티를 사용하면 타입 프로퍼티 및 타입 메서드를 호출할 수 있다.


```swift
// 시스템 음량은 한 기기에서 유일한 값이어야 한다.
struct SystemVolume {
    // 타입 프로퍼티를 사용하면 언제나 유일한 값이 된다.
    static var volume: Int = 5
    
    // 타입 프로퍼티를 제어하기 위해 타입 메서드를 사용한다.
    static func mute() {
        self.volume = 0     // SystemVolume.volume과 같은 표현
                            // Self.volume = 0과도 같은 표현
    }
}

// 네비게이션 역할은 여러 인스턴스가 수행할 수 있다.
class Navigation {
    
    // 네비게이션 인스턴스마다 음량을 따로 설정할 수 있다.
    var volume: Int = 5
    
    // 길 안내 음성 재생
    func guideWay() {
        // 네비게이션 외 다른 재생원 음소거
        SystemVolume.mute()
    }
    
    // 길 안내 음성 종료
    func finishGuideWay() {
        // 기존 재생원 음량 복구
        SystemVolume.volume = self.volume
    }
}

SystemVolume.volume = 10

let myNavi: Navigation = Navigation()

myNavi.guideWay()
print(SystemVolume.volume)  // 0

myNavi.finishGuideWay()
print(SystemVolume.volume)  // 5 
```